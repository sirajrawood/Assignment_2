<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Siraj Rawood, RWDMOH001">

<title>A Quarto Website - Assignment2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">A Quarto Website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./RWDMOH001.html" rel="" target="" aria-current="page">
 <span class="menu-text">Assignment2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./ChatGPT.html" rel="" target="">
 <span class="menu-text">ChatGPT</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation">Data Preparation</a></li>
  <li><a href="#method" id="toc-method" class="nav-link" data-scroll-target="#method">Method</a>
  <ul class="collapse">
  <li><a href="#sentiment-analysis" id="toc-sentiment-analysis" class="nav-link" data-scroll-target="#sentiment-analysis">Sentiment Analysis</a></li>
  <li><a href="#topic-modelling" id="toc-topic-modelling" class="nav-link" data-scroll-target="#topic-modelling">Topic Modelling</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#sentiment-analysis-1" id="toc-sentiment-analysis-1" class="nav-link" data-scroll-target="#sentiment-analysis-1">Sentiment Analysis</a></li>
  <li><a href="#topic-modelling-1" id="toc-topic-modelling-1" class="nav-link" data-scroll-target="#topic-modelling-1">Topic Modelling</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  <li><a href="#github" id="toc-github" class="nav-link" data-scroll-target="#github">Github</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Assignment2</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Siraj Rawood, RWDMOH001 </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<div style="page-break-after: always;"></div>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>For this assignment we will concentrate on working with text data and using different methods to clean the data, making it usable for sentiment analysis and topic modelling. The data we will be using are the State of the Nation speeches in South Africa between 1994 and 2023. Analyising the sentiments over different speeches given by different presidents as well as finding the overarching topics for the speeches. Sentiment analysis will help in understanding the overall emotion and tone of the speeches and we will be able to see how this changes over time across the different presidents. Topic modelling on the other hand is a way for different documents (in our case the different speeches) to be summarised according to a set number of topics. This however is not necessarily as straightforward since the summary is left to interpretation based on the variety of words that fall into the topic. We will also view this over the different presidents and how this changes over time.</p>
<p>To start the analysis we first load the packages needed as well as the data with an introduction to the dataset. Then we can begin data cleaning and preprocessing, leading to the initial exploration of the dataset.We set out the methods to follow for performing sentiment analysis and for topic modelling. The enxt section are the results obtained from the methods section and finally a conclusion to summarise the findings and main ideas of the assignment.</p>
<p>Aside from this report, a brief explanation on how ChatGPT was used to aid in this assignment is provided. This was done to assess the ability of whether such a a model is indeed able to help and the validity of the help.</p>
</section>
<section id="data-preparation" class="level1">
<h1>Data Preparation</h1>
<p>The data is contained within the <code>sona-addresses-1994-2023.zip</code> file. It contains text files for each of the State of the Nation Address (SONA) speeches from 1994 to 2023 given by the South African president of the corresponding year. This is an annual even in which provides an opportunity for the country’s president to address the nation, its legislative body (e.g., parliament or congress), and the broader public on the status of the country and priorities for the future.The data can be sourced from the <a href="https://www.gov.za/state-nation-address">SONA website</a>. Since this event happens twice during an election year, the file comprises of 36 speeches.</p>
<p>We make use of the <code>sona-first-steps.R</code> file provided to read in the data. The files reads in all the text files and provides a data frame where each speech is an observation, with important columns being the president name, the date/year of the speech among others. Lastly, the date and unnecessary whitespace is removed.</p>
<p>Now that the initial data preparation is done, we can tokenise the data - a unit of text to use for analysis: in this case into words and sentences. The <code>unnest_tokens()</code> function splits the text into a new data frame with one token per row, making the data tidy. We further clean the data by removing the dates and certain punctuation and escape sequences. Lastly we also remove stop words.</p>
</section>
<section id="method" class="level1">
<h1>Method</h1>
<section id="sentiment-analysis" class="level2">
<h2 class="anchored" data-anchor-id="sentiment-analysis">Sentiment Analysis</h2>
<p>Sentiment analysis is a method in which the emotional context of text can be assessed - for instance, are the words conveying a positive or negative emotion or meaning. This is done using a sentiment lexicon in which a variety of words have been assigned an outcome (dependant on the lexicon) - therefore making this a classification problem. For the data we are using, it can be used to provide some political analysis, seeing the overall tone and emotion of a speech, alluding to the governemnts view of the performance of the country and its outlook.</p>
<p>As mentioned, a sentiment lexicon is integral. We have opted to use the <em>bing</em> lexicon. This contains a variety of words and assigns it to have either a positive or negative sentiment. To use this, we have joined it onto the tokenised words - showing the sentiment of each word used by each president for a given speech. We have also set words outside of the lexicon to neutral - the hope is that all or at least most of the emotive words have been captured.</p>
<p>We then look at the most frequently used positive and negative words used by each president as well as how sentiment changes over time for the different presidents. To do this we look at the net sentiment of the speeches - the amount of positive words minus the negative words.</p>
</section>
<section id="topic-modelling" class="level2">
<h2 class="anchored" data-anchor-id="topic-modelling">Topic Modelling</h2>
<p>Topic modeling is a natural language processing technique used to identify latent topics within a collection of documents. Its primary objective is to uncover the underlying themes or topics that contribute to the content of a large corpus. To do this we will be focusing on using Latent Dirichlet Allocation (LDA). In LDA, each document is considered a mix of various topics, and each topic is a probability distribution over words (a mixutre of words). The model assumes that documents are generated based on this probabilistic process, where words are selected from topics, and the mixture of topics determines the overall content of the document. However the number of topics over which to choose from needs to be set. This can be seen as a shortfall as how the outcome is interpreted is highly dependant on this. Choosing a small number of topics can help to summarise the documents very well but may not be able to identify all the distinct topics, whereas a large number of topics may be able to identify all the unqie topics in the corpus, however it won’t really summarise the overarching theme in the corpus. It may also dilute the topics, making them fairly similar and redundant.</p>
<p>In order to do this we make use of the <em>topicmodels</em> and <em>ldatuning</em> packages. Before we can proceed with topic modelling, we need to format the data using <code>cast_dtm()</code>, this creates a DocumentTermMatrix object. In order to perform LDA, the number of topics needs to be chosen. In order to do this we use the <code>FindTopicsNumber()</code>. The output can be seen below:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  topics Griffiths2004 CaoJuan2009 Arun2010
1     10     -722587.0   0.1252683 107.6611
2      9     -723451.9   0.1306858 112.1537
3      8     -723526.2   0.1636107 114.5250
4      7     -726580.7   0.1826739 115.3153
5      6     -730108.3   0.2107762 119.5070
6      5     -737220.2   0.3097658 123.9413
7      4     -749333.8   0.4087572 129.9062
8      3     -760985.8   0.4814322 137.4474
9      2     -776742.0   0.5223058 148.0905</code></pre>
</div>
<div class="cell-output-display">
<p><img src="RWDMOH001_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>From this plot, it is ideal to choose the number of topics where it begins to plateau, being about 6. However with 6 presidents it is possible the topics may cluster around the individual presidents themselves and not around summarising the speeches too well. Moreover, 2 presidents only gave one speech each. Therefore we will opt for 4 topics instead. Now we use the <code>LDA()</code> function, specifying <code>k=4</code> for the topics. The outout produces <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\gamma\)</span> values where <span class="math inline">\(\beta\)</span> is a parameter that gives the probability of a topic generating a particular word and <span class="math inline">\(\gamma\)</span> gives the proportions of topics in a document.</p>
<p>We assess the <span class="math inline">\(\beta\)</span> values for the word-topic probabilities to see which words correspond to which topic, allowing us to make assumptions on what the topic is about. We then assess the <span class="math inline">\(\gamm\)</span> values for each document to see what the overarching topic is for each speech.</p>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<section id="sentiment-analysis-1" class="level2">
<h2 class="anchored" data-anchor-id="sentiment-analysis-1">Sentiment Analysis</h2>
<p>The figure below shows the positive words each president used the most throughout their speeches. From this figure we can see that “regard” appears most often for Mandela, Mbeki and Motlanthe while “support” is most often for Ramaphosa and Zuma. Both deKlerk and Mandela say “freedom” and “peace”. Alluding to the political climate of Apartheid. Mbeki, Ramaphosa and Zuma make use of the word “progress” along with either “empowerment: or”reform” as well, due to all the policies and reforms they implemented.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="RWDMOH001_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p><u><em>Figure 1: Top 10 Positive Words Said per President.</em></u></p>
<p>Figure 2 below shows the negative words each president used the most throughout their speeches. We can see deKlerk uses “concerns”, most likely to keep addressing the concerns people may have regarding the upcoming change. All presidents (excpet deKlerk) are addressing the crime and corruption in the country, as well as the the “poor” things.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="RWDMOH001_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p><u><em>Figure 2: Top 10 Negative Words Said per President.</em></u></p>
<p>Lastly we also observe the net sentiment over time. It can seen that the general sentiment over the years are all positive except that of deKlerk, being the only negative sentiment speech. We can see that Mbeki shows very high positive sentiments, this was a time where the country was experiencing good growth. The same can be said for Ramaphosa.His speeches are generally positive. For Zuma we can see how it becomes decreasingly positive towards the end of his tenure, possibly due to all the allegations and controversies surrounding him.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="RWDMOH001_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p><u><em>Figure 3: Net Sentiment per President Over the Years.</em></u></p>
</section>
<section id="topic-modelling-1" class="level2">
<h2 class="anchored" data-anchor-id="topic-modelling-1">Topic Modelling</h2>
<p>We first assess the <span class="math inline">\(\beta\)</span> values for each the word-topic probabilities. The greater the value, the more likely the word is to come from that topic. We can assess the words that tend to make up each topic to get an idea of what the topics are that summarise our documents. This can be seen by the figure below:</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="RWDMOH001_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p><u><em>Figure 4: Words per topic with highest values.</em></u></p>
<p>From this we now have an idea of what the different topics comprise of, however not with complete certainty. We will also consider the document-topic probabilities (<span class="math inline">\(\gamma\)</span> values) before making assumptions based on the meanings of the topics.Figure 5 shows for each president, which topic their speeches mostly belong to. Now using both Figure 4 and Figure 5 we can begin to understand the topics.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="RWDMOH001_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p><u><em>Figure 5: Gamma Distribution by Topic for Each President.</em></u></p>
<p>Figure 5 above shows for deKlerk his speech topic is between 1 and 2 (not well shown). Mandela is mostly topic 1 and 4, Mbeki fluctuates between 1 and 4, Ramaphosa mainly 2 and Zuma mostly 3. Due to the number of topics and the number of presidents that gave multiple speeches being the same, it can be suggested that the topics found are very closely related to the president that delivered the speech. However, it can be see that the document-topic probabilities do still change for some of the presidents. From Figure 4 and 5, we can come to the following conclusions.</p>
<p><strong>Topic 1</strong> contains words relating to the state of the country. We see the words “freedom”, “past” and “people” appearing. These topics also relate to speeches from Mbeki, Mandela and deKlerk.</p>
<p><strong>Topic 2</strong> contains words relating to economic growth. This was the main topics for Ramaphosa and deKlerk based around time of drastic change for the country.</p>
<p><strong>Topic 3</strong> contains words relating to the development of the countries infrastructure and different sectors. What stands out is the word “honourable” and it can be seen how Zuma’s speeches fall into this topic as well - he used this more often than the other presidents.</p>
<p><strong>Topic 4</strong> contains words relating to the social development, the programmes and policies put into place. This topic relates to Mandela and Mbeki, who did a lot of work for the country regarding this.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>In this assignment we have shown how to clean text data making it ready for sentiment analysis and topic modelling, being able to extract information from the data without having to go through everything individually. The data used for the assignment was text data from the SONA speeches over the years 1994 to 2023.</p>
<p>We have shown there were many steps involved in preparing the data and care must be taken to get it into a tidy format. Once that is done, how we can use sentiment analysis to find the overall sentiments from each of the presidents over the years. Using topic modelling we also could see the overall theme for the different speeches, showing what the imoprtant points were for each speech.</p>
<p>Something to consider for the sentiment analysis is whether different lexicons should be used. This will also give a different view of the sentiments of the presidents. There is also the choice in the number of topics to choose when conduction LDA. One can adjust these to see if the topics still accurately summarise the different speeches.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<p>Durbach, I. 2023. Data Science for Industry Notes. Statistical Sciences Department, University of Cape Town.</p>
<p>R Core Team. 2022. R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.</p>
<p>Wickham H., François R., Henry L., Müller K., Vaughan D. 2023. <em>dplyr: A Grammar of Data Manipulation</em>. R package version 1.1.3, https://CRAN.R-project.org/package=dplyr.</p>
<p>Wickham, H. 2022. <em>stringr: Simple, Consistent Wrappers for Common String Operations</em>. R package version 1.5.0, <a href="https://CRAN.R-project.org/package=stringr" class="uri">https://CRAN.R-project.org/package=stringr</a>.</p>
</section>
<section id="github" class="level1">
<h1>Github</h1>
<p><a href="https://github.com/sirajrawood/Assignment_2">GitHub Repo</a></p>
<p>https://github.com/sirajrawood/Assignment_2</p>
<p><a href="https://sirajrawood.github.io/Assignment_2/">GitHub Pages Website</a></p>
<p>https://sirajrawood.github.io/Assignment_2/</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>